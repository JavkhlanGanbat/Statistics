<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="mn" xml:lang="mn"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>statreport</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="statreport_files/libs/clipboard/clipboard.min.js"></script>
<script src="statreport_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="statreport_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="statreport_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="statreport_files/libs/quarto-html/popper.min.js"></script>
<script src="statreport_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="statreport_files/libs/quarto-html/anchor.min.js"></script>
<link href="statreport_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="statreport_files/libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="statreport_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="statreport_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="statreport_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#оршил" id="toc-оршил" class="nav-link active" data-scroll-target="#оршил">Оршил</a></li>
  <li><a href="#өгөгдөл" id="toc-өгөгдөл" class="nav-link" data-scroll-target="#өгөгдөл">Өгөгдөл</a>
  <ul class="collapse">
  <li><a href="#өгөгдлийн-эх-үүсвэр-ба-зорилго" id="toc-өгөгдлийн-эх-үүсвэр-ба-зорилго" class="nav-link" data-scroll-target="#өгөгдлийн-эх-үүсвэр-ба-зорилго">Өгөгдлийн эх үүсвэр ба зорилго</a></li>
  <li><a href="#өгөгдлөө-цэвэрлэх" id="toc-өгөгдлөө-цэвэрлэх" class="nav-link" data-scroll-target="#өгөгдлөө-цэвэрлэх">Өгөгдлөө цэвэрлэх</a></li>
  <li><a href="#өгөгдөл-хуваах" id="toc-өгөгдөл-хуваах" class="nav-link" data-scroll-target="#өгөгдөл-хуваах">Өгөгдөл хуваах</a></li>
  <li><a href="#урьдчилсан-боловсруулалт" id="toc-урьдчилсан-боловсруулалт" class="nav-link" data-scroll-target="#урьдчилсан-боловсруулалт">Урьдчилсан боловсруулалт</a></li>
  </ul></li>
  <li><a href="#загварын-хэрэгжүүлэлт" id="toc-загварын-хэрэгжүүлэлт" class="nav-link" data-scroll-target="#загварын-хэрэгжүүлэлт">Загварын хэрэгжүүлэлт</a>
  <ul class="collapse">
  <li><a href="#логистик-регрессийн-үндэс" id="toc-логистик-регрессийн-үндэс" class="nav-link" data-scroll-target="#логистик-регрессийн-үндэс">Логистик регрессийн үндэс</a></li>
  <li><a href="#сигмойд-функц" id="toc-сигмойд-функц" class="nav-link" data-scroll-target="#сигмойд-функц">Сигмойд функц</a></li>
  <li><a href="#алдааны-функц" id="toc-алдааны-функц" class="nav-link" data-scroll-target="#алдааны-функц">Алдааны функц</a></li>
  <li><a href="#l2-тогтворжуулалт-regularization" id="toc-l2-тогтворжуулалт-regularization" class="nav-link" data-scroll-target="#l2-тогтворжуулалт-regularization">L2 тогтворжуулалт (regularization)</a></li>
  <li><a href="#градиент-бууруулалт-gradient-descent" id="toc-градиент-бууруулалт-gradient-descent" class="nav-link" data-scroll-target="#градиент-бууруулалт-gradient-descent">Градиент бууруулалт (Gradient descent)</a></li>
  <li><a href="#сурах-хурдны-бууралт-оновчтой-конвергенц" id="toc-сурах-хурдны-бууралт-оновчтой-конвергенц" class="nav-link" data-scroll-target="#сурах-хурдны-бууралт-оновчтой-конвергенц">Сурах хурдны бууралт: Оновчтой конвергенц</a></li>
  <li><a href="#классын-жинлэлт-тэнцвэргүй-өгөгдөлтэй-ажиллах" id="toc-классын-жинлэлт-тэнцвэргүй-өгөгдөлтэй-ажиллах" class="nav-link" data-scroll-target="#классын-жинлэлт-тэнцвэргүй-өгөгдөлтэй-ажиллах">Классын жинлэлт: Тэнцвэргүй өгөгдөлтэй ажиллах</a></li>
  <li><a href="#пайплайн" id="toc-пайплайн" class="nav-link" data-scroll-target="#пайплайн">Пайплайн</a></li>
  </ul></li>
  <li><a href="#үр-дүн" id="toc-үр-дүн" class="nav-link" data-scroll-target="#үр-дүн">Үр дүн</a>
  <ul class="collapse">
  <li><a href="#ерөнхий-гүйцэтгэл" id="toc-ерөнхий-гүйцэтгэл" class="nav-link" data-scroll-target="#ерөнхий-гүйцэтгэл">Ерөнхий гүйцэтгэл:</a></li>
  <li><a href="#confusion-матриц" id="toc-confusion-матриц" class="nav-link" data-scroll-target="#confusion-матриц">Confusion матриц</a></li>
  <li><a href="#класс-тус-бүр-дээрх-гүйцэтгэл" id="toc-класс-тус-бүр-дээрх-гүйцэтгэл" class="nav-link" data-scroll-target="#класс-тус-бүр-дээрх-гүйцэтгэл">Класс тус бүр дээрх гүйцэтгэл</a></li>
  <li><a href="#онцлогийн-ач-холбогдол" id="toc-онцлогийн-ач-холбогдол" class="nav-link" data-scroll-target="#онцлогийн-ач-холбогдол">Онцлогийн ач холбогдол</a></li>
  <li><a href="#магадлалын-тархалт" id="toc-магадлалын-тархалт" class="nav-link" data-scroll-target="#магадлалын-тархалт">Магадлалын тархалт</a></li>
  <li><a href="#pr-trade-off" id="toc-pr-trade-off" class="nav-link" data-scroll-target="#pr-trade-off">PR Trade-off</a></li>
  <li><a href="#онцлогийн-жин" id="toc-онцлогийн-жин" class="nav-link" data-scroll-target="#онцлогийн-жин">Онцлогийн жин</a></li>
  <li><a href="#сигмоид-функц-ба-магадлалын-тархалт" id="toc-сигмоид-функц-ба-магадлалын-тархалт" class="nav-link" data-scroll-target="#сигмоид-функц-ба-магадлалын-тархалт">Сигмоид функц ба магадлалын тархалт</a></li>
  <li><a href="#дүгнэлт" id="toc-дүгнэлт" class="nav-link" data-scroll-target="#дүгнэлт">Дүгнэлт</a></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="statreport.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></nav>
</div>
<main class="content" id="quarto-document-content">




<section id="оршил" class="level1">
<h1>Оршил</h1>
<p>Энэ төслийн зорилго нь хувь хүний жилийн орлого 50,000 ам.доллараас дээш эсэхийг таамаглах явдал юм. Бид АНУ-ын Хүн амын тооллогын Adult Income өгөгдлийн санг ашиглан орлогын түвшинг урьдчилан таамаглах загвар боловсруулна. Энэхүү өгөгдлийн сан нь нас, боловсрол, мэргэжил, гэр бүлийн байдал зэрэг олон хувьсагчийг агуулдаг бөгөөд эдгээр нь хувь хүний санхүүгийн байдалд нөлөөлдөг гол хүчин зүйлс юм.</p>
<p>Төслийн үндсэн зорилго нь зөвхөн таамаглал гаргах бус, өгөгдөл дэх хамаарал, классын тэнцвэргүй байдал, оролцож буй хувьсагчдын нөлөөллийг ойлгож, загварын үйл ажиллагааг үнэлэхэд оршино. Энд бид логистик регрессийг ашиглан хоёртын ангиллын асуудлыг шийдвэрлэх ба загварын үзүүлэлтүүд нь орлогыг зөв таамаглах боломжийг хэр сайн хангаж байгааг илтгэнэ. Үүнээс гадна энэ төсөл нь өгөгдлийн шинжилгээ, ангиллын загварчлал болон статистик үндэслэлтэй шийдвэр гаргалтын практик дадлага олгоно.</p>
</section>
<section id="өгөгдөл" class="level1">
<h1>Өгөгдөл</h1>
<section id="өгөгдлийн-эх-үүсвэр-ба-зорилго" class="level2">
<h2 class="anchored" data-anchor-id="өгөгдлийн-эх-үүсвэр-ба-зорилго">Өгөгдлийн эх үүсвэр ба зорилго</h2>
<p>Бид Kaggle платформын Income Dataset буюу орлогын мэдээллийг ашигласан. Энэ өгөгдлийн багц дотор нас, боловсрол, мэргэжил, гэрлэлтийн байдал, хүйс зэрэг нийгэм-эдийн засгийн шинж чанаруудыг илэрхийлэх хувьсагчид бий. Бидний зорилтот хувьсагч бол <code>income_&gt;50K</code> (0 = <span class="math inline">\(\leq50K\)</span>, 1 = <span class="math inline">\(&gt;50K\)</span>). Өгөгдлийг цэвэрлэсний дараа үлдсэн хувьсагчууд дээр тулгуурлан энэ хувьсагчийн утгыг зөв таамаглах нь бидний үндсэн зорилго юм.</p>
<p>Түүврийн нийт хэмжээ нь ойролцоогоор 44,000 бөгөөд бид үүнийг сургах болон үнэлгээ хийх 2 хэсэг болгож хуваана. Хуваалтын дараа 35,165 сургалт, 8,792 баталгаажуулалтын хэсгийг бүрдүүлнэ.</p>
<p>Гэхдээ энэ өгөгдөлтэй ажиллах томоохон бэрхшээл нь классуудын тэнцвэргүй байдал юм. Ихэнх хүмүүс (<span class="math inline">\(\approx\)</span> 76%) <span class="math inline">\(\leq50K\)</span> орлоготой. Харин цөөнх хувь нь (<span class="math inline">\(\approx\)</span> 24%) <span class="math inline">\(&gt;50K\)</span> орлоготой.</p>
<p>Бид үргэлж <span class="math inline">\(\leq50K\)</span> гэж таадаг гэнэн модел гаргасан ч accuracy нь 76% болно гэсэн үг. Иймээс бид 2 классыг хоёуланг нь оновтойгоор авч үздэг логистик регресс загвар гаргах ёстой болоод байна. Үүний тулд F1 оноо, Recall зэрэг үзүүлэлтүүдийг чухалчилна.</p>
</section>
<section id="өгөгдлөө-цэвэрлэх" class="level2">
<h2 class="anchored" data-anchor-id="өгөгдлөө-цэвэрлэх">Өгөгдлөө цэвэрлэх</h2>
<p>Өгөгдлийн хэлбэр:</p>
<p><span class="math inline">\([\)</span> <code>age</code>,<code>workclass</code>,<code>fnlwgt</code>,<code>education</code>,<code>educational-num</code>,<code>marital-status</code>,<code>occupation</code>,<code>relationship</code>,<code>race</code>,<code>gender</code>,<code>capital-gain</code>,<code>capital-loss</code>,<code>hours-per-week</code>,<code>native-country</code>,<code>income_&gt;50K</code> <span class="math inline">\(]\)</span></p>
<p>Бид анхны өгөгдөлөө давхардсан, ач холбогдол багатай буюу тайлбарлахад хэцүү баганыг арилгаж хялбаршуулсан.</p>
<p><strong>Ашигласан хувьсагчид (9):</strong></p>
<ul>
<li><p>Тоон (5): <code>age</code>, <code>educational-num</code>, <code>capital-gain</code>, <code>capital-loss</code>, <code>hours-per-week</code></p></li>
<li><p>Чанарын (4): <code>education</code>, <code>marital-status</code>, <code>occupation</code>, <code>gender</code></p></li>
</ul>
</section>
<section id="өгөгдөл-хуваах" class="level2">
<h2 class="anchored" data-anchor-id="өгөгдөл-хуваах">Өгөгдөл хуваах</h2>
<p>Бид өгөгдлийг сургалт/баталгаажуулалт гэсэн хоёр хэсэгт <strong>80/20</strong> харьцаатайгаар, хоёр хэсэгт <code>income_&gt;50K</code> классын харьцаа тэнцүү байхаар хувааж, <code>train_split.csv</code>, <code>val_split.csv</code> файлд хадгалсан. Анхны өгөгдлийн багц дотор <code>income_&gt;50K</code>-н 76% нь 0, 24% нь 1 утгатай бол хуваасны дараа энэ харьцаа эвдлээгүй гэсэн үг.</p>
</section>
<section id="урьдчилсан-боловсруулалт" class="level2">
<h2 class="anchored" data-anchor-id="урьдчилсан-боловсруулалт">Урьдчилсан боловсруулалт</h2>
<p><strong>Тоон хувьсагчид:</strong><br>
StandardScaler нь тоон хувьсагч бүрийг дундаж утга нь 0, стандарт хазайлт нь 1 болохоор нормальчилдаг. Бүх хувьсагчийг түүврийн дундаж руу нь төвлөрүүлснээр градиент дээр суурилсан алгоритмууд илүү хурдан, тогтвортой суралцахад тусална.</p>
<p><span class="math display">\[
X_{\text{scaled}} = \frac{X - \mu}{\sigma}
\]</span></p>
<p><strong>Чанарын хувьсагчид:</strong><br>
OneHotEncoder нь нэг чанарын хувьсагчийг тус бүрийн чанаруудыг илэрхийлэх хоёртын вектор лүү хөрвүүлж, тоон утгаар илэрхийлдэг нь машин сургалтын алгоритмуудад зохимжтой болгоно. Ямар ч дараалал, зэрэглэл авч үздэггүй.</p>
<p>Жишээлбэл, <code>education</code> гэх чанарын хувьсагчийг авч үзье.</p>
<p><span class="math inline">\([E = \{\text{HS}, \text{Bachelors}, \text{Masters}, \text{Doctorate}\}]\)</span></p>
<p>One-hot кодчилол нь уг хувьсагчийг дараах байдлаар хувиргана:</p>
<p><span class="math display">\[
f(x) = \begin{cases} [1, 0, 0, 0] &amp; \text{if } x = \text{HS} \\[1mm][0, 1, 0, 0] &amp; \text{if } x = \text{Bachelors} \\[1mm][0, 0, 1, 0] &amp; \text{if } x = \text{Masters} \\[1mm][0, 0, 0, 1] &amp; \text{if } x = \text{Doctorate} \end{cases}
\]</span></p>
<p>Кодлогдсон онцлог (feature) бүр нь одоо Бернуллийн санамсаргүй хувьсагч болно.</p>
<p><strong>Загварын гиперпараметр:</strong></p>
<ul>
<li><p><code>learning_rate</code> ойролцоогоор 0.1</p></li>
<li><p><code>max_iter</code> ойролцоогоор 800</p></li>
<li><p><code>reg_lambda</code> = 1e-4 (L2)</p></li>
<li><p><code>lr_decay</code> = 1e-4</p></li>
<li><p><code>threshold</code> = 0.5 (шийдвэрийн хязгаар)</p></li>
</ul>
</section>
</section>
<section id="загварын-хэрэгжүүлэлт" class="level1">
<h1>Загварын хэрэгжүүлэлт</h1>
<p>Бид энэ төсөлд логистик регрессийн загварыг гараар хэрэгжүүлсэн. Яагаад гэвэл sklearn-ийн <code>LogisticRegression</code> нь олон зүйлийг автоматаар хийдэг бөгөөд бид хэрхэн ажилладгийг нь ойлгохыг илүүд үзлээ. Мөн сурах хурдны бууралт, class weighting зэрэг сонирхолтой зүйлсийг өөрсдөө туршиж үзэхийг хүссэн.</p>
<section id="логистик-регрессийн-үндэс" class="level2">
<h2 class="anchored" data-anchor-id="логистик-регрессийн-үндэс">Логистик регрессийн үндэс</h2>
<p>Логистик регресс нь хоёртын ангилал хийх суурь загваруудын нэг юм. Шугаман регресс нь тасралтгүй утгуудыг таамагладаг бол логистик регресс нь аливаа инстанц нь тодорхой классын байх магадлалыг тооцоолдог.</p>
<p>Оролтын хувьсагч <span class="math inline">\(\mathbf{x}\)</span> -н хувьд <span class="math display">\[
P(y = 1 \mid \mathbf{x})
\]</span></p>
<p>буюу гаралт <span class="math inline">\(y\)</span> нь <span class="math inline">\(1\)</span>-тэй тэнцүү байх магадлалыг олох зорилготой.</p>
<p>Эхлээд бид оролтуудын шугаман тэгшитгэлийг бодно:</p>
<p><span class="math display">\[
z_i = \mathbf{w}^\top \mathbf{x}_i + b
\]</span></p>
<p>Үүнд:</p>
<ul>
<li><span class="math inline">\(\mathbf{w}\)</span> = жингийн вектор (сурах параметрүүд)</li>
<li><span class="math inline">\(b\)</span> = хазайлтын утга</li>
<li><span class="math inline">\(\mathbf{x}_i\)</span> = түүврийн онцлогийн вектор <span class="math inline">\(i\)</span></li>
<li><span class="math inline">\(z_i\)</span> = logit” буюу log odds</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> issparse(X_array):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> X_array.dot(<span class="va">self</span>.weights) <span class="op">+</span> <span class="va">self</span>.bias</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> np.dot(X_array, <span class="va">self</span>.weights) <span class="op">+</span> <span class="va">self</span>.bias</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="сигмойд-функц" class="level2">
<h2 class="anchored" data-anchor-id="сигмойд-функц">Сигмойд функц</h2>
<p>Сигмойд функц нь дээрх шугаман нийлбэр <span class="math inline">\(z\)</span> -ийг магадлал болгоно.</p>
<p><span class="math display">\[
\sigma(z) = \frac{1}{1 + e^{-z}}
\]</span></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sigmoid(<span class="va">self</span>, z):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> np.exp(<span class="op">-</span>np.clip(z, <span class="op">-</span><span class="dv">500</span>, <span class="dv">500</span>)))  <span class="co"># overflow-оос сэргийлэх</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Эндээс модел нэг түүврийн хувьд таамаглах магадлал нь дараах томъёгоор илэрхийлэгдэнэ:</p>
<p><span class="math display">\[
\hat{p}_i = P(y_i = 1 \mid \mathbf{x}_i) = \sigma(z_i) = \sigma(\mathbf{w}^T \mathbf{x}_i + b)
\]</span></p>
</section>
<section id="алдааны-функц" class="level2">
<h2 class="anchored" data-anchor-id="алдааны-функц">Алдааны функц</h2>
<p>Одоо бид загварыг яаж сургахын тулд алдааны функцийг тодорхойлох хэрэгтэй. Логистик регресст binary cross-entropy хэмээх ойлголтыг ашигладаг.</p>
<p>Нэг таамаглалын хувьд алдаа нь:</p>
<p><span class="math display">\[
\ell = -\left[y \log(\hat{y}) + (1-y)\log(1-\hat{y})\right]
\]</span></p>
<p>Үүнд:</p>
<ul>
<li><span class="math inline">\(y\)</span> = жинхэнэ утга (0 or 1)</li>
<li><span class="math inline">\(\hat{y}\)</span> = таамагласан утга</li>
</ul>
<p>Cross-entropy нь загварыг итгэлтэйгээр буруу таамаглал гаргахыг илүү шийтгэдэг. Өөрөөр хэлбэл 1 эсвэл 0-тэй маш ойрхон магадлал (0.99, 0.01 г.м.) гаргаад энэ нь буруу болж таарвал алдаа нь өндөр гарч ирнэ.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Таамаглал <span class="math inline">\(\hat{y}\)</span></th>
<th>Алдаа <span class="math inline">\(-\log(\hat{y})\)</span></th>
<th>Шийтгэлийн түвшин</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0.99 (итгэлтэй, зөв)</td>
<td>0.01</td>
<td>Маш бага</td>
</tr>
<tr class="even">
<td>0.50 (итгэл багатай)</td>
<td>0.69</td>
<td>Дунд зэргийн</td>
</tr>
<tr class="odd">
<td>0.10 (итгэлтэй, буруу)</td>
<td>2.30</td>
<td>Том</td>
</tr>
<tr class="even">
<td>0.01 (маш итгэлтэй, буруу)</td>
<td>4.61</td>
<td>Маш том</td>
</tr>
</tbody>
</table>
<p><span class="math display">\[
L_{\text{CE}} = -\frac{1}{m}\sum_{i=1}^{m}
\left[
y_i \log(\hat{y}_i) + (1 - y_i)\log(1 - \hat{y}_i)
\right].
\]</span></p>
</section>
<section id="l2-тогтворжуулалт-regularization" class="level2">
<h2 class="anchored" data-anchor-id="l2-тогтворжуулалт-regularization">L2 тогтворжуулалт (regularization)</h2>
<p>Хэт том утгатай жингээс үүдэлтэй overfitting-ээс сэргийлнэ</p>
<p><span class="math display">\[
\frac{\lambda}{2m}\|\mathbf{w}\|^2
\]</span></p>
<p>Үүнд:</p>
<ul>
<li><p><span class="math inline">\(\lambda\)</span> = тогтворжуулалтын хэмжээ (гиперпараметр)</p></li>
<li><p><span class="math inline">\(m\)</span> = түүврийн хэмжээ</p></li>
<li><p><span class="math inline">\(\|\mathbf{w}\|^2 = w_1^2 + w_2^2 + \cdots + w_n^2\)</span></p></li>
</ul>
<p>Нийт алдаа:</p>
<p><span class="math display">\[
L = -\frac{1}{m}\sum_{i=1}^{m}\left[y_i\log(\hat{y}_i) + (1-y_i)\log(1-\hat{y}_i)\right] + \frac{\lambda}{2m}\|\mathbf{w}\|^2
\]</span></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_loss(<span class="va">self</span>, y_true, y_pred, sample_weights<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(y_true)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    epsilon <span class="op">=</span> <span class="fl">1e-15</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    y_pred <span class="op">=</span> np.clip(y_pred, epsilon, <span class="dv">1</span> <span class="op">-</span> epsilon)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    sample_losses <span class="op">=</span> <span class="op">-</span>(y_true <span class="op">*</span> np.log(y_pred) <span class="op">+</span> </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>                      (<span class="dv">1</span> <span class="op">-</span> y_true) <span class="op">*</span> np.log(<span class="dv">1</span> <span class="op">-</span> y_pred))</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> sample_weights <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        sample_losses <span class="op">=</span> sample_losses <span class="op">*</span> sample_weights</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    cross_entropy <span class="op">=</span> np.mean(sample_losses)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    l2_penalty <span class="op">=</span> (<span class="va">self</span>.reg_lambda <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> m)) <span class="op">*</span> np.<span class="bu">sum</span>(<span class="va">self</span>.weights <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cross_entropy <span class="op">+</span> l2_penalty</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="градиент-бууруулалт-gradient-descent" class="level2">
<h2 class="anchored" data-anchor-id="градиент-бууруулалт-gradient-descent">Градиент бууруулалт (Gradient descent)</h2>
<p>Одоо манай алдагдлын функц бий. Гэхдээ нийт алдааг хэрхэн багасгахын тулд градиент бууруулалт гэж нэрлэгддэг аргыг ашиглана. Энэ тохиолдолд градиент гэдэг нь жингүүдийн аль чиглэлд өөрчлөгдөх үед алдаа нь хамгийн хурдтай өсөж буурахыг илэрхийлдэг вектор.. Градиент бууруулалтын үндсэн санаа нь уг градиентыг тооцоолоход оршино.</p>
<p>Жин шинэчлэлийн дүрэм:</p>
<p><span class="math display">\[
\begin{aligned}
w &amp;\leftarrow w - \alpha \cdot \nabla_w J \\
b &amp;\leftarrow b - \alpha \cdot \nabla_b J
\end{aligned}
\]</span></p>
<p>Энд <span class="math inline">\(\alpha\)</span> бол <strong>сурах хурд</strong> — бид хэр хурдан алхах вэ гэдгийг тодорхойлдог. Градиентууд нь:</p>
<p><span class="math display">\[
\begin{aligned}
\nabla_w J &amp;= \frac{1}{m}X^\top(\hat{y} - y) + \frac{\lambda}{m}w \\
\nabla_b J &amp;= \frac{1}{m}\sum_{i=1}^{m}(\hat{y}^{(i)} - y^{(i)})
\end{aligned}
\]</span></p>
<p>Кодонд:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _compute_gradients(<span class="va">self</span>, X, y, y_pred):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(y)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    error <span class="op">=</span> y_pred <span class="op">-</span> y</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Жингийн градиент + L2</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    dw <span class="op">=</span> (<span class="dv">1</span><span class="op">/</span>m) <span class="op">*</span> X.T.dot(error)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="va">self</span>.reg_lambda <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        dw <span class="op">+=</span> (<span class="va">self</span>.reg_lambda <span class="op">/</span> m) <span class="op">*</span> <span class="va">self</span>.weights</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Bias-ийн градиент</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    db <span class="op">=</span> (<span class="dv">1</span><span class="op">/</span>m) <span class="op">*</span> np.<span class="bu">sum</span>(error)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dw, db</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="сурах-хурдны-бууралт-оновчтой-конвергенц" class="level2">
<h2 class="anchored" data-anchor-id="сурах-хурдны-бууралт-оновчтой-конвергенц">Сурах хурдны бууралт: Оновчтой конвергенц</h2>
<p>Нэг асуудал: хэрэв сурах хурд хэт өндөр бол, алдагдлын функцийн минимумыг алдаж, “bounce around” хийж магадгүй. Хэт бага бол, маш удаан сургана. Шийдэл нь юу вэ? <strong>Сурах хурдны бууралт</strong> — эхлээд том алхамуудаар эхлээд, цаг хугацааны явцад багасгана:</p>
<p><span class="math display">\[
\alpha_t = \frac{\alpha_0}{1 + \text{decay} \cdot t}
\]</span></p>
<p>Энэ нь загварт эхэндээ хурдан суралцах, дараа нь минимумын ойролцоо нарийвчлалтай алхах боломж олгоно. Кодонд:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> iteration <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.max_iter):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Одоогийн сурах хурдыг тооцоолох</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    current_lr <span class="op">=</span> <span class="va">self</span>.initial_lr <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> <span class="va">self</span>.lr_decay <span class="op">*</span> iteration)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Жингүүдийг шинэчлэх</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.weights <span class="op">-=</span> current_lr <span class="op">*</span> dw</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.bias <span class="op">-=</span> current_lr <span class="op">*</span> db</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="классын-жинлэлт-тэнцвэргүй-өгөгдөлтэй-ажиллах" class="level2">
<h2 class="anchored" data-anchor-id="классын-жинлэлт-тэнцвэргүй-өгөгдөлтэй-ажиллах">Классын жинлэлт: Тэнцвэргүй өгөгдөлтэй ажиллах</h2>
<p>Манай өгөгдөлд 76% нь <span class="math inline">\(\leq50K\)</span>, 24% нь <span class="math inline">\(&gt;50K\)</span> байна. Хэрэв бид юу ч хийхгүй бол, загвар зүгээр л “бүх зүйл <span class="math inline">\(\leq50K\)</span>” гэж таамаглаж, 76% нарийвчлалд хүрч магадгүй — гэхдээ энэ нь ямар ч хэрэггүй юм!</p>
<p>Шийдэл нь <strong>классын жинлэлт</strong> юм. Бид цөөнх классын (&gt;50K) алдааг илүү “чухал” болгоно:</p>
<p><span class="math display">\[
w_{\text{class}} = \frac{m}{2 \cdot m_{\text{class}}}
\]</span></p>
<p>Кодонд:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">self</span>.class_weight <span class="op">==</span> <span class="st">'balanced'</span>:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    classes <span class="op">=</span> np.unique(y)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    weights <span class="op">=</span> <span class="bu">len</span>(y) <span class="op">/</span> (<span class="bu">len</span>(classes) <span class="op">*</span> np.bincount(y.astype(<span class="bu">int</span>)))</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    sample_weights <span class="op">=</span> weights[y.astype(<span class="bu">int</span>)]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    sample_weights <span class="op">=</span> np.ones(<span class="bu">len</span>(y))</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Алдагдлыг тооцоолохдоо sample_weights ашиглах</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>loss <span class="op">=</span> <span class="op">-</span>np.mean(sample_weights <span class="op">*</span> (y <span class="op">*</span> np.log(y_pred_clipped) <span class="op">+</span> </span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>                                   (<span class="dv">1</span> <span class="op">-</span> y) <span class="op">*</span> np.log(<span class="dv">1</span> <span class="op">-</span> y_pred_clipped)))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="пайплайн" class="level2">
<h2 class="anchored" data-anchor-id="пайплайн">Пайплайн</h2>
<p>Sklearn-ийн <code>Pipeline</code> нь бүх зүйлийг зохион байгуулахад туслана. Бид preprocess (StandardScaler + OneHotEncoder) болон манай custom LogisticRegression-г нэг л обьект болгон нэгтгэж чаддаг:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> Pipeline</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.compose <span class="im">import</span> ColumnTransformer</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler, OneHotEncoder</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Тоон ба категори баганыг тусгаарлах</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>num_features <span class="op">=</span> [<span class="st">'age'</span>, <span class="st">'educational-num'</span>, <span class="st">'capital-gain'</span>, <span class="st">'capital-loss'</span>, <span class="st">'hours-per-week'</span>]</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>cat_features <span class="op">=</span> [<span class="st">'education'</span>, <span class="st">'marital-status'</span>, <span class="st">'occupation'</span>, <span class="st">'gender'</span>]</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Preprocessing pipeline</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>preprocessor <span class="op">=</span> ColumnTransformer([</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'num'</span>, StandardScaler(), num_features),</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'cat'</span>, Pipeline([</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'encoder'</span>, OneHotEncoder(drop<span class="op">=</span><span class="st">'first'</span>, sparse_output<span class="op">=</span><span class="va">False</span>, handle_unknown<span class="op">=</span><span class="st">'ignore'</span>))</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    ]), cat_features)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Бүтэн pipeline</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> Pipeline([</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'preprocess'</span>, preprocessor),</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'logreg'</span>, LogisticRegression(</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        learning_rate<span class="op">=</span><span class="fl">0.1</span>, max_iter<span class="op">=</span><span class="dv">800</span>, reg_lambda<span class="op">=</span><span class="fl">1e-4</span>,</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>        lr_decay<span class="op">=</span><span class="fl">1e-4</span>, class_weight<span class="op">=</span><span class="st">'balanced'</span>, threshold<span class="op">=</span><span class="fl">0.5</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    ))</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>model.fit(X_train, y_train)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
</section>
<section id="үр-дүн" class="level1">
<h1>Үр дүн</h1>
<section id="ерөнхий-гүйцэтгэл" class="level2">
<h2 class="anchored" data-anchor-id="ерөнхий-гүйцэтгэл">Ерөнхий гүйцэтгэл:</h2>
<p>Эдгээр тоонууд юу гэсэн үг вэ? Бидний загвар ерөнхийдөө сайн ажилладаг боловч цөөнх классыг (&gt;50K) таних нь илүү хэцүү байна. Энэ нь тэнцвэргүй өгөгдлийн ердийн асуудал юм.</p>
</section>
<section id="confusion-матриц" class="level2">
<h2 class="anchored" data-anchor-id="confusion-матриц">Confusion матриц</h2>
<p>Confusion матриц нь манай алдаануудын төрлийг харуулна:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/conmatrix.png" class="img-fluid figure-img"></p>
<figcaption>Confusion матриц</figcaption>
</figure>
</div>
<p>Яагаад вэ? Өгөгдөл тэнцвэргүй байгаа учраас, энэ загвар байнга олонх классыг (<span class="math inline">\(\leq50K\)</span>) харахаар сургагдсан. Энэ нь цөөнх классыг таних нь хэцүү болгодог.</p>
</section>
<section id="класс-тус-бүр-дээрх-гүйцэтгэл" class="level2">
<h2 class="anchored" data-anchor-id="класс-тус-бүр-дээрх-гүйцэтгэл">Класс тус бүр дээрх гүйцэтгэл</h2>
<p>Класс тус бүрээр нарийвчлан харвал:</p>
<p><strong><span class="math inline">\(\leq50K\)</span> анги (олонх):</strong> - Precision: 0.89 - Recall: 0.91<br>
- F1: 0.90</p>
<p>Загвар энэ классыг амархан таньдаг.</p>
<p><strong><span class="math inline">\(&gt;50K\)</span> анги (цөөнх):</strong> - Precision: 0.66 - Recall: 0.59 - F1: 0.62</p>
<p>Илүү муу. Энэ нь тэнцвэргүй өгөгдлийн шууд үр дагавар — цөөн дээжтэй ангиудыг суралцах нь хэцүү.</p>
</section>
<section id="онцлогийн-ач-холбогдол" class="level2">
<h2 class="anchored" data-anchor-id="онцлогийн-ач-холбогдол">Онцлогийн ач холбогдол</h2>
<p>Жингүүдийг харахад, юу хамгийн чухал болохыг харж болно. Эхний 5 эерэг ба сөрөг онцлогууд:</p>
<p><strong>Эерэг нөлөө (&gt;50K рүү ойртуулах):</strong></p>
<ol type="1">
<li><p><strong><code>educational-num</code> (+0.89):</strong> Боловсрол өндөр байх тусам орлого өндөр байх магадлал ихтэй.</p></li>
<li><p><strong><code>capital-gain</code> (+0.76):</strong> Хэрэв та хөрөнгө оруулалтаас орлого олж байвал орлого өндөр байх магадлал дээшилнэ.</p></li>
<li><p><strong><code>marital-status_Married-civ-spouse</code> (+0.46):</strong> Гэрлэсэн хүмүүс илүү тогтвортой орлоготой байх хандлагатай.</p></li>
<li><p><strong><code>occupation_Exec-managerial</code> (+0.52):</strong> Удирдах албан тушаал = илүү өндөр цалин.</p></li>
<li><p><strong><code>hours-per-week</code> (+0.28):</strong> Илүү их ажилласан = илүү их мөнгө.</p></li>
</ol>
<p><strong>Сөрөг нөлөө (<span class="math inline">\(\leq50K\)</span> рүү ойртуулах):</strong></p>
<ol type="1">
<li><p><strong><code>occupation_Other-service</code> (-0.67):</strong> Үйлчилгээний ажил ихэвчлэн бага цалинтай.</p></li>
<li><p><strong><code>marital-status_Never-married</code> (-0.48):</strong> Ганц бие байх нь бага орлоготой холбоотой (гэхдээ бодит байдалд бусад хүчин зүйлээс шалтгаалж магадгүй).</p></li>
<li><p><strong><code>capital-loss</code> (-0.41):</strong> Хөрөнгийн алдагдал санхүүгийн асуудлын шинж тэмдэг.</p></li>
<li><p><strong><code>education_HS-grad</code> (-0.32):</strong> Бүрнэ дунд боловсрол дангаараа өндөр орлого хангахад хүрэлцэхгүй.</p></li>
</ol>
</section>
<section id="магадлалын-тархалт" class="level2">
<h2 class="anchored" data-anchor-id="магадлалын-тархалт">Магадлалын тархалт</h2>
<p>Сигмоид функц шугаман нийлбэр буюу linear combination-ийг (<span class="math inline">\(z = w_1 x_1 + w_2 x_2 + \dots + w_n x_n + b\)</span>) магадлал руу хөрвүүлдэг.</p>
<p><strong><span class="math inline">\(\leq50K\)</span> хүмүүсийн хувьд:</strong> - Дундаж магадлал (&gt;50K байх): <strong>0.18</strong> - Ихэнх нь 0-0.3 хооронд</p>
<p>Загвар эдгээр хүмүүсийг 100% эерэг биш гэж бодож байна, гэхдээ ихэвчлэн магадлалыг бага байлгадаг.</p>
<p><strong><span class="math inline">\(&gt;50K\)</span> хүмүүсийн хувьд:</strong> - Дундаж магадлал: <strong>0.57</strong> - Илүү өргөн тархалттай (0.2-0.9)</p>
<p>Зарим &gt;50K орлоготой хүмүүс өндөр магадлалтай (0.9+) гарч байгаа ч, зарим нь харьцангуй бага магадлалтай (0.2–0.4) байна. Энэ магадлалын давхцал нь загвар төгс ажиллахаас өөр аргагүйг харуулж байна. Зарим өгөгдөл дээр тодорхой ангилалт хийх хэцүү.</p>
</section>
<section id="pr-trade-off" class="level2">
<h2 class="anchored" data-anchor-id="pr-trade-off">PR Trade-off</h2>
<p>Яагаад бид 100% precision ба 100% recall-д зэрэг хүрч чадахгүй гэж?</p>
<p>Математик талаас боломжгүй, учир нь ангиуд заримдаа давхцдаг. Манай магадлалын тархалтын график үүнийг тодорхой харуулна. Зарим өндөр орлоготой хүмүүсийг загвар бага магадлалтай гэж үзэж, зарим <span class="math inline">\(\leq50K\)</span> хүмүүс өндөр магадлалтай гэж үнэлдэг. Иймээс бид аль ч загвараар 100% зөв ангилах боломжгүй.</p>
<p>Загварын ерөнхий гүйцэтгэлийг ROC AUC=0.891 үзүүлж байна. Энэ нь санамсаргүй таамаглалаас (0.5) илүү сайн бөгөөд ангилалд дунджаар үнэлгээ сайн байгааг харуулна. Төгс үзүүлэлт биш (1.0), гэхдээ оюутны төсөлд анхны оролдлого болгон маш сайн гүйцэтгэл юм.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/PRC.png" class="img-fluid figure-img"></p>
<figcaption>Precision-Recall ба ROC муруйнууд</figcaption>
</figure>
</div>
<p>Зүүн талын Precision–Recall муруй нь бидний хамгийн том шийдвэрийн тэнцвэрийг илтгэнэ. Recall-ийг өсгөх үед илүү олон өндөр орлоготой хүмүүсийг илрүүлэх боломжтой ч, босго оноо доошлохын хэрээр Precision буурч, буруу эерэг таамаглал нэмэгддэг. Харин Precision-ийг сайжруулахын тулд илүү хатуу босго тавибал загвар зөв таамаглалд илүү итгэлтэй болох авч, олон жинхэнэ өндөр орлоготой хүмүүсийг орхигдуулах эрсдэлтэй. Энэ муруй нь хоёр классын үл тэнцвэртэй өгөгдлийн үед бодит гүйцэтгэлийг илүү үнэн зөв харуулдаг тул стратегийн хувьд түлхүүр үзүүлэлт болдог.</p>
<p>Баруун талын ROC муруй харьцангуй ерөнхий дүр зургийг өгч, манай загварын ялгах чадвар AUC = 0.891 гэдгийг харуулж байна. Энэ нь санамсаргүй таамаглалаас эрс илүү гүйцэтгэлтэй боловч ROC муруйн нь үл тэнцвэртэй өгөгдөлд хэт өгөөмөр ханддаг гэдгийг мартаж болохгүй. Иймээс өндөр AUC үзүүлэлт нь өөрөө хангалттай биш: практикт бид босго оноог бодитоор тохируулж, Precision ба Recall-ийн хооронд төслийн зорилгод нийцсэн зөв тэнцвэрийг олох шаардлагатай хэвээр байна.</p>
</section>
<section id="онцлогийн-жин" class="level2">
<h2 class="anchored" data-anchor-id="онцлогийн-жин">Онцлогийн жин</h2>
<p>Жингүүд нь онцлогийн чухал байдлыг харуулна. Эерэг жин = өндөр орлого руу түлхэх, сөрөг жин = бага орлого руу түлхэх:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/features.png" class="img-fluid figure-img"></p>
<figcaption>Хамгийн чухал 15 онцлогийн жин</figcaption>
</figure>
</div>
<p>Хамгийн өндөр нөлөөтэй хүчин зүйлс:</p>
<ol type="1">
<li><strong>educational-num (+0.89):</strong> Боловсролын түвшин. Энэ нь хамгийн хүчтэй эерэг нөлөөтэй хүчин зүйл болж байна. Боловсрол өндөр байх тусам орлого өндөр байх магадлал эрс нэмэгдэнэ.</li>
<li><strong>capital-gain (+0.76):</strong> Хөрөнгө оруулалтын ашиг. Санхүүгийн нэмэлт эх үүсвэртэй байх нь өндөр орлогын тод шинж тэмдэг юм.</li>
<li><strong>occupation_Other-service (-0.67):</strong> Үйлчилгээний салбарын ажил. Энэ нь орлогод сөргөөр нөлөөлж байна, өөрөөр хэлбэл энэ салбарт ажиллагсад <span class="math inline">\(\leq50K\)</span> классд орох магадлал өндөр.</li>
<li><strong>marital-status_Never-married (-0.48):</strong> Гэрлэж байгаагүй. Ганц бие хүмүүс гэр бүлтэй хүмүүстэй харьцуулахад орлого багатай байх хандлага ажиглагдсан.</li>
<li><strong>marital-status_Married-civ-spouse (+0.46):</strong> Гэрлэсэн байдал. Эсрэгээрээ, гэр бүлийн тогтвортой байдал нь өндөр орлоготой эерэг хамааралтай байна.</li>
</ol>
<p>Эдгээр үр дүн нь нийгэм, эдийн засгийн бодит байдалтай бүрэн нийцэж байна. Загвар маань зүгээр нэг тоо таах биш, бодит амьдралын зүй тогтлыг олж харсан гэж дүгнэж болно.</p>
</section>
<section id="сигмоид-функц-ба-магадлалын-тархалт" class="level2">
<h2 class="anchored" data-anchor-id="сигмоид-функц-ба-магадлалын-тархалт">Сигмоид функц ба магадлалын тархалт</h2>
<p>Сигмоид функц нь загварын гаргасан тоон үнэлгээг (score) магадлал руу хөрвүүлдэг. Зүүн талд математик функц, баруун талд бидний загварын бодит таамаглалууд хэрхэн тархсаныг харуулж байна:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/sigmoid.png" class="img-fluid figure-img"></p>
<figcaption>Сигмоид функц ба магадлалын тархалт</figcaption>
</figure>
</div>
<p><strong>Гол ойлголт:</strong> Зүүн талын график нь онолын хэсэг — <span class="math inline">\(z=0\)</span> үед магадлал яг 0.5 байна. Харин баруун талын гистограм нь бодит байдлыг харуулна:</p>
<ul>
<li><strong>Улаан хэсэг (<span class="math inline">\(\leq50K\)</span>):</strong> Ихэнх нь 0-0.3 магадлалтай байна. Загвар энэ хүмүүсийг бага орлоготой гэдэгтээ нэлээд итгэлтэй байна.</li>
<li><strong>Ногоон хэсэг (&gt;50K):</strong> Тархалт нь 0.2-оос 0.9 хүртэл маш өргөн байна. Энд давхцал их байгааг анзаараарай.</li>
<li>Энэ давхцал нь яагаад бид 100% нарийвчлалтай байж чадахгүйг тайлбарладаг. Зарим өндөр орлоготой хүмүүс бага орлоготой хүмүүстэй ижил шинж чанартай (эсвэл эсрэгээрээ) байгаа тул загвар тэднийг ялгахад хүндрэлтэй байна.</li>
</ul>
</section>
<section id="дүгнэлт" class="level2">
<h2 class="anchored" data-anchor-id="дүгнэлт">Дүгнэлт</h2>
<p>Энэхүү төсөл нь логистик регрессийг практикт хэрэгжүүлэх явцдаа зөвхөн алгоритмын ажиллагаа төдийгүй өгөгдлийн чанар, статистик ойлголтууд загварын гүйцэтгэлд ямар их нөлөөтэйг бодитоор мэдрэх боломж олголоо. Загвар тогтвортой суралцаж, хэт тохируулалт ажиглагдаагүй нь зөв регуляризацийн сонголт болон градиент бууруулалтын тохиргоо оновчтой байсны илрэл юм. Гэсэн хэдий ч гүйцэтгэл, ялангуяа accuracy нь 80% давахгүй байгаа нь өгөгдлийн бүтэц, классын тэнцвэргүй байдал зэрэгтэй холбоотой.</p>
<p>Ирээдүйд Random Forest, Gradient Boosting зэрэг илүү нарийн төвөгтэй загваруудыг ашиглавал &gt;50K орлоготой хүмүүсийг илүү найдвартай таамаглах боломжтой. Гол сургамж нь зөвхөн Accuracy-аас гадна Precision, Recall, ROC/AUC зэрэг үзүүлэлтүүдийг ойлгон, загварын хязгаарлалт, өгөгдлийн чанарыг хамтад нь үнэлэх хэрэгтэй гэдгийг харуулж байна.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>